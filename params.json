{"name":"Something about DNS","tagline":"Calle tries to explain DNS","body":"# What is DNS?\r\n\r\nDNS is a distributed read-mostly fault-tolerant hierarchical database,\r\nwhere different partitions are controlled by different people.\r\n\r\nThe most common _use_ of DNS, by far, is to look up IP addresses from\r\nhuman-readable names. It was originally created in order to do exactly\r\nthat. Still, if we want to understand DNS we must not confuse the tool\r\nwith what the tool is used for. DNS is a database. A very specialized\r\none, and a fairly odd one, but still a database. It has keys, which\r\nare used to look up (or store!) pieces of data.\r\n\r\n# How is data in DNS organized?\r\n\r\n## Part 1: the Tree\r\n\r\nThe first and most obvious structure of DNS is the tree of names. The\r\nsort of name we usually see on the Internet, like `www.google.com` is an\r\naddress to a specific node in this tree. Since this is a computer\r\nscience tree and not a real-world tree, the root of it is at the\r\nright-hand edge of the name. It's also invisible, so the name in the\r\nexample above is actually `www.google.com.<invisible root>`.\r\nSometimes, when we need to be really specific, we type the dot before\r\nthe invisible root, like so: `www.google.com.`.\r\n\r\nThe names in the DNS tree are addresses of _nodes_ in the tree.\r\n`www.google.com` is the address of a node. `google.com` is the address\r\nof a different node, and `com` is another one. The root node is\r\nusually written as a single dot (`.`) when we need to refer to it.\r\n\r\nWe'll get to what is _in_ the nodes in the next section.\r\n\r\nSo, if all nodes are independent and have their own addresses, what's\r\nthe point of the tree thing? Why have I bothered to mention this root\r\nthing several times already? Well, it's pretty simple. It's how we let\r\ndifferent people control different parts. In DNS, we can say \"You\r\npeople control everything from this node down\". So, for example, ICANN\r\n(the non-profit organization who controls the root node) has given\r\ncontrol of `com` to a company called Verisign, of `se` to the nation\r\nof Sweden and of `ninja` to a company called United TLD Holdco Ltd. At\r\nthe time I write this, there are a bit over nine hundred names at the\r\nroot level. We call this process of handing over control _delegation_.\r\nSo we say that ICANN has _delegated_ `mil` to the United States\r\nmilitary, and `nz` to the nation of New Zealand. Verisign, who as you\r\nremember controls `com`, has delegated `google.com` to Google.\r\n\r\nDelegation can only happen in between names (at the dots, so to\r\nspeak). It's not possible to give control of part of a name to\r\nsomeone, and another part to someone else. That's part of why when\r\nCzechoslovakia split into the Czech Republic and Slovakia back in\r\n1993, the name `cs` was retired and the newly formed nations got `cz`\r\nand `sk` instead (the other reason is that national domains are named\r\nafter their ISO 3166-1 country codes).\r\n\r\nAlso note that delegation does not _have_ to happen. It's perfectly\r\npossible to keep control of lots of levels of names below one you\r\nhave. As an example, the vast majority of people who control a domain\r\nhave a name `www` below that domain, and they keep control of it\r\nthemselves.\r\n\r\nA name and all the names below it that are not delegated to someone\r\nelse is collectively called a _zone_.\r\n\r\nWe'll get back to how delegation happens technically later, after\r\nwe've talked about a couple of other things we need to know first,\r\nsince it's one of the areas in DNS that causes the most confusion.\r\n\r\n## Part 2: the Nodes\r\n\r\nNodes in the DNS tree contain zero or more _resource records_ (nearly\r\nalways abbreviated to RR in technical texts). Each resource record\r\nhas a _class_ and a _type_, as well as some content. Let's talk about\r\nthe classes first, so we can get them out of the way and forget them.\r\n\r\nThere are three possible classes: `HS` for Hesiod, `CH` for ChaosNet\r\nand `IN` for Internet. Guess which one of those you will use very,\r\nvery nearly 100% of the time? So if you look at a zone file and wonder\r\nwhy it says `IN` everywhere, the answer is that back when all this was\r\ndesigned nobody knew that the Internet was going to wipe out all\r\ncompetition.\r\n\r\nAnyway.\r\n\r\nThe _type_ of a record is much more interesting. It specifies what\r\nkind of data the record holds. It's the equivalent of the type of a\r\ncolumn in an SQL database table, except that the actual types are\r\npretty different. There are about 75 different kinds of resource\r\nrecord types defined, but most of them are very rarely used. Only\r\nabout a dozen or so are commonly seen. The type that someone not\r\nspecifically working with DNS is most likely to encounter is `A`,\r\nwhich holds an IPv4 address. The second most likely one is `CNAME`,\r\nwhich is unfortunate, because it is also *by far* the most\r\nmisunderstood of all RR types. We'll spend a whole section on it\r\nlater, after we've talked a bit about how delegation works.\r\n\r\nOther resource record types that may be interesting to at least have\r\nheard the names of are:\r\n\r\n* SOA\r\n    \r\n    \"Start Of Authority\". This one must exist at the top level of each\r\n    zone, and holds some information that pertains to the zone as a\r\n    whole, such as how long caches are allowed to remember data about\r\n    it without checking with a source.\r\n\r\n* MX\r\n    \r\n    \"Mail eXchange\". This one tells mail transfer agents which server\r\n    they should talk to in order to deliver mail addressed to the\r\n    domain.\r\n\r\n* TXT\r\n    \r\n    \"TeXT\". Just a bit of text. This can have something to do with DNS\r\n    itself (the `se` zone uses one to let people know the last time\r\n    the zone was updated), or be something completely different (at\r\n    least one person have used them to implement a text adventure\r\n    game).\r\n\r\n## Putting it together a little\r\n\r\nSo we have names, which point out nodes, and in the nodes there are\r\nrecords which hold data. In order to find something, for example the\r\nIPv6 addresses associated with the name `www.facebook.com`, we use\r\nthree things as a lookup key: the name, the RR class and the RR type.\r\nThe name, `www.facebook.com`, says which node to look in, while the\r\nclass and type says which records in that node we want. Since the RR\r\nclass is in practice always `IN`, we often talk about lookups as being\r\n\"an AAAA lookup for www.facebook.com\" (AAAA is the RR type for IPv6\r\naddresses, if you didn't guess that). There can be many records in a\r\nnode with the same class and type, as long as they have different data\r\nin them. It's also possible for a node to have no records at all in it.\r\n\r\n# Looking Things Up\r\n\r\n## Climbing down the tree\r\n\r\nLike all databases, DNS has servers. Unlike most databases, it has\r\n_millions_ of servers. The tricky part of looking things up in DNS is\r\nto figure out which server to ask. Fortunately, there's a procedure\r\nfor it. We start at the root, and follow a trail down. Or, I guess,\r\nfollow it left, to keep the tree directed the same way as we had it\r\nearlier in this text. Somewhat simplified, if we want to look up the\r\nIPv4 address for `www.example.org` it goes like this:\r\n\r\n1) We: \"Root servers? Give me A records for www.example.org.\"\r\n\r\n2) Root servers: \"www.example.org? Go ask the servers for org.\"\r\n\r\n3) We: \"Org servers? Give me A records for www.example.org.\"\r\n\r\n4) Org servers: \"www.example.org? Go ask the servers for example.org.\"\r\n\r\n5) We: \"Example.org servers? Give me A records for www.example.org.\"\r\n\r\n6) Example.org servers: \"Sure. Here you are.\"\r\n\r\nIt's a bit more complicated in practice, of course, since we have to\r\nfind the IP addresses for all those name servers. And we need to\r\nhandle that sometimes things don't work out as they're supposed to.\r\nMaybe the `example.org` servers give us an answer that's not so\r\nhelpful (\"Go ask the root servers\"), gives us one that's complete\r\nnonsense (\"CROCODILES!\") or don't answer at all. But roughly speaking\r\nthis is how it works.\r\n\r\nThis process of following pointers down the tree is known as doing a\r\n_recursive query_ or _recursing_.\r\n\r\n## Delegation\r\n\r\nIn the description above, we blithely skate over the phrase \"ask the\r\nservers for\". Let's get into that a bit more.\r\n\r\nEvery zone has a set of servers that have _authoritative_ information\r\nabout the zone. That is, information that has been directly input from\r\noutside the DNS system, and is treated as correct by definition. How\r\nmany such servers a zone has is up to the zone's operators, but it is\r\nvery strongly recommended that there be at least two. The list of\r\nauthoritative name servers for a zone is stored as NS records at the\r\ntopmost name of the zone. That is, the list of name servers for\r\n`example.org` is stored as `NS` resource records in the DNS tree node\r\n`example.org`.\r\n\r\nAnd therein lies a bootstrapping problem. Look at steps 2 and 4 in the\r\ndescription of the recursion process above. It's all fine and good to\r\ntell us to go ask another zone's servers, but how do we know which\r\nthose servers are? Well, the answer to that is actually really easy. A\r\nlist of them is included in the response. Except that only pushes the\r\nproblem up a step, because how do the root zone servers know about the\r\nservers for `org` or the `org` servers know about the servers for\r\n`example.org`. It gets even worse if the servers are _in_ the zone\r\nbeing looked up (`ns1.example.org` and `ns2.example.org`, say),\r\nbecause then in order to look up their IP addresses we already have\r\nknow their IP addresses.\r\n\r\nThis deadlock is broken by manual intervention. When a zone is\r\ndelegated, information about its nameservers is added to the\r\n_delegating_ zone. So externally added information about a zone's name\r\nservers exists in two places: in the zone's own authoritative name\r\nservers and in the delegating zone's name servers. To use the nodes in\r\na tree model, it is as if the node where a delegation happens has a\r\n\"shadow\" node behind it, that belongs to the zone above and only has\r\nname server information in it. The IP address information in the\r\n\"shadow\" node (if any) is usually called \"glue\", since it's used to\r\nstick the delegated zone to the delegating zone. You could see it as\r\ngluing the branch to the tree, I guess.\r\n\r\nThe problem here, and the part that causes endless confusion, is that\r\nthe information in the two nodes (the real one and the shadow one) has\r\nto be kept consistent manually. If there's a change of name server, it\r\nhas to be noted in _both_ places. Service providers often try to hide\r\nthis from end users in their various control panels and other user\r\ninterfaces, which is a nice thought but (in my opinion) only adds to\r\nthe confusion in the long run.\r\n\r\nAnd now it's time for a really scary part.\r\n\r\n## The Horror of CNAME\r\n\r\nIf you've been doing web stuff, you've heard about CNAME. Most likely,\r\nyou have no idea what it actually is, except that it is some sort of\r\nmagic that makes a URL go somewhere else. The amount of confusion\r\nabout this that can be found even on very serious question-and-answer\r\nsites (like Stack Overflow and Serverfault) is staggering. Indeed,\r\nexposure to it prompted the writing of this text, in the hope that\r\nmaybe it will stop someone somewhere at some time from having to ask a\r\nreally ignorant question.\r\n\r\nSo anyway.\r\n\r\nCNAME is a resource record type (type number 5, to be precise). The\r\ndata stored in it is a domain name. What it does is this:\r\n\r\n    If, when doing a recursive domain name lookup, the name being\r\n    looked up does not have any records of the requested type, but it\r\n    does have a record of type CNAME, the lookup is restarted with the\r\n    name from the CNAME record (unless the type queried for was CNAME,\r\n    in which case the lookup is complete and the CNAME record itself\r\n    is the response), and the result of this lookup is used as the\r\n    result of the original query.\r\n\r\nPhew! Let's pick that apart, shall we? An example is probably easiest.\r\n\r\nLet's say we want to look up the IPv6 addresses of `www.facebook.com`.\r\nWe issue a recursive query for `AAAA` records for the name\r\n`www.facebook.com` (and of class `IN`, of course). The recursion goes\r\nfrom the root to `com` to `facebook.com`. The servers for\r\n`facebook.com` tell us that there are no `AAAA` records for\r\n`www.facebook.com`, but there _is_ a `CNAME` record. The name stored\r\nin the `CNAME` is `star.c10r.facebook.com.`.\r\n\r\nSo we restart the query. Same record type, same record class,\r\ndifferent name. We go from the root, to `com`, to `facebook.com`, to\r\n`c10r.facebook.com`, which tells us that there is an `AAAA` record for\r\nthe name `star.c10r.facebook.com.`, and the IPv6 address is\r\n`2a03:2880:2110:df07:face:b00c::1`. Which then is the result of the\r\noriginal query for `www.facebook.com`'s `AAAA` records.\r\n\r\nThat's what a `CNAME` does. That's _all_ a `CNAME` does. It says to do\r\nthe query over with a different name, and pretend the result was for\r\nthe original name.\r\n\r\nOK, there is one more wrinkle. If we have a `CNAME` record in a node,\r\nwe must not have any other records in the same node (except if the\r\nzone is using DNSSEC, in which case the node may also have `RRSIG`,\r\n`NSEC` and `NSEC3`, but you can safely pretend I never even wrote\r\nthat). The reasons for this are kind of technical and esoteric, but\r\nfor the most part boil down to \"What the heck would it *mean*?\".\r\n\r\nAn immediate consequence of this rule is that we can't have a CNAME at\r\nthe top level of a zone, since it would collide at least with the `NS`\r\nand `SOA` records that must exist there (and the `MX` that usually does).\r\nThis annoys web hosting providers. Why it does is left as an exercise\r\nfor the interested reader.\r\n\r\n# DNSSEC\r\n\r\nLet's conclude by saying something about DNSSEC, the addition to the\r\nbase DNS system that makes it possible to be sure that the data we\r\nfind in DNS is not fake.\r\n\r\n## The Problem\r\n\r\nDNS was designed back when the Internet was a nice place, where\r\neveryone could be trusted. This means that the only security in it is\r\nmeant to protect against accidents, not against malice. Which in turn\r\nmeans that it's pretty easy for a malicious entity to corrupt the data\r\nin it. As a response to that, eventually _DNSSEC_ was introduced. It\r\nadds cryptographic security to DNS. It also adds quite a bit of\r\ncomplexity, needs more network bandwidth and memory, and makes it\r\nvastly less forgiving of errors. Even so, I recommend that you use it\r\nif you can.\r\n\r\n## How it works\r\n\r\nDNSSEC adds cryptographic signatures to DNS. Specifically, it signs\r\nwhat we call _RRsets_. An RRset is simply all the RRs in a node that\r\nhave the same type and class but different data. All the `A` records,\r\nfor example, or all the `NS` records. That is, exactly the sort of\r\nlump of information you can ask for. When DNSSEC is active (that is,\r\nthe server supports it and the query is asking for it), every RRset\r\ngets one or more _signatures_ sent along with it, in the form of\r\n`RRSIG` records. At the top level of the zone there is also one or\r\nmore `DNSKEY` records, which contain the public half of public-key\r\nkeys. The `DNSKEY` records are used to verify that the `RRSIG`\r\nsignatures were made from the relevant RRset with the secret half of\r\nthe public key.\r\n\r\nTake a moment to let that sink in. The zone has `DNSKEY` records,\r\nwhich can be used to cryptographically verify signatures of RR sets\r\nstored in `RRSIG` records.\r\n\r\nThat's how it works _in_ a zone. Delegation from one zone to another\r\nneeds to be handled as well. This is done by adding a record type to\r\nthe \"shadow\" node we talked about before, the one that has data about\r\none zone but is actually stored in the servers of the parent zone.\r\nThis new record type, which _only_ exists in the \"shadow\" node, is\r\ncalled `DS`, for \"delegation signer\". It contains a cryptographic hash\r\nof a `DNSKEY` record in the child zone, and it is signed with the\r\nparent zone's key (or keys). So if we trust the parent, we can verify\r\nthat one of the keys in the child is OK, and we can then use that key\r\nto verify that other records in the child are OK too.\r\n\r\nSo how do we know if we can trust the parent? Well, we check _its_\r\nparent, and the delegation from it, of course. And so on up until we\r\nget to the root zone. For that, we have to add some information\r\nmanually. It's called a _trust anchor_, and it basically is another\r\npublic half of a key. You can get it from the\r\n[Internet Assigned Numbers Authority](https://www.iana.org/dnssec/files)\r\n(IANA for short). Most DNSSEC-aware software today comes with it\r\nincluded, so you probably don't have to care about that, but it's nice\r\nto know where it comes from. That key is the root of all trust in\r\nDNSSEC, and needless to say it is handled _very_ carefully.\r\n\r\nThat is the skeleton of how DNSSEC works. There's a mind-boggling\r\namount of detail that I've skipped over, like signature lifespans,\r\nchoices of cryptographic algorithms and verified non-existence (how\r\nyou can be cryptographically sure that a record does not exist). But\r\nif you understand the description above, you have a good grasp of\r\nwhere the trust in DNSSEC comes from.\r\n\r\n## Advantages and disadvantages\r\n\r\nThe one huge advantage of DNSSEC is that you can trust the information\r\nyou get out of DNS. You can _know_ that the IP address you just got is\r\nthe one your bank published for its Internet banking web site, and not\r\nsomething the NSA or a Russian mob injected. This in turn enables\r\nother technologies that are just now being explored, like distributing\r\nSSL certificates via secure DNS in order to make pretty much\r\neverything on the Internet more secure.\r\n\r\nThe main disadvantage of DNSSEC is its complete unforgiveness of\r\nmistakes. Traditional DNS is extremely resilient against doing things\r\nwrong. You can mess things up to an amazing degree, and things will\r\nstill more or less work.\r\n\r\nNot so with DNSSEC. One of the things with DNSSEC is that if the\r\ncrypto stuff doesn't verify properly, the data is treated as if it did\r\nnot exist at all. Which means that if you get things wrong at the\r\nsigning level, the entire zone vanishes from the Internet. There is no\r\ngrey area. There is no \"it sort of works\" as with traditional DNS.\r\nEither it works, or the zone doesn't exist.\r\n\r\nAnother drawback, although less significant, is that DNSSEC makes for\r\nquite a bit more network traffic. The response packet to an A query\r\nfor `www.iis.se` is 55 bytes without DNSSEC, 221 bytes with it. That's\r\na 400% increase. On the other hand, we're still talking _bytes_, not\r\nkilobytes or megabytes, so for most people the increase is just noise.\r\nBut for a large hosting provider it can become significant.\r\n\r\n## DNSSEC vs. X.509\r\n\r\nOne criticism of DNSSEC that I've heard a couple of times is that it's\r\njust as bad as the X.509 certificates used in SSL, since both rely on\r\na chain of verication back to a trusted source. I do not agree with\r\nthat criticism, and I'll try to explain why.\r\n\r\nFirst, there is the number of trusted sources. DNSSEC has exactly one,\r\nthe root trust anchor. The Mozilla root CA bundle at the time I write\r\nthis has 177. If nothing else, it will be much more noticeable if a\r\nsingle source goes bad than if one out of almost two hundred does.\r\n\r\nSecond, in DNSSEC the chain of trust is defined. The path of signed\r\ndata must follow the path of delegation. There can be no unexpected\r\ndetours that might introduce something bad. In X.509, there is no such\r\ndefined path. As long as there is _any_ path of signed data between\r\nthe endpoint and a root certificate, the endpoint is considered to be\r\nOK. As an example, nobody except Verisign (who controls `com.`) can\r\ncreate a signed DNSSEC delegation to `google.com.`. In contrast, a\r\nvalid SSL certificate for `google.com` can be created not only by any\r\none of the 177 root CAs in the Mozilla bundle - but also by anyone to\r\nwhom those 177 roots have issued delegated CA certificates. So in\r\nDNSSEC we have to trust Verisign, while for SSL we can't even tell\r\n_how many_ entities we have to trust, much less who they are.\r\n\r\nThird, in DNSSEC an operator only extends trust to the level\r\nimmediately below them. `com.` signs `google.com.`, but they cannot\r\nsign `mail.google.com.`. In X.509, any root CA can create a\r\ncertificate for any other name no matter how distant.\r\n\r\nFinally, since there can be only one trusted path to a domain, any\r\nmanipulation will be highly noticeable. In X.509, adding another\r\ntrusted path from a root CA to a certificate has no effect on any\r\nexisting certificates for the same name. In DNSSEC, changing the\r\nsigned delegation path means that the previous delegation stops\r\nworking.\r\n\r\nIn short, I personally trust DNSSEC a whole lot more than I trust\r\nX.509. You, of course, get to make your own choice.\r\n\r\n# That's all for now\r\n\r\nI do hope that you now feel that you have a better understanding of\r\nhow DNS works, and that when next you see someone asking how they can\r\nmake a `CNAME` work only for some URL paths on their web site, you can\r\ngive them an _informed_ chewing out.\r\n\r\nHave fun out there in Internetland!\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}