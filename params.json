{"name":"Something about DNS","tagline":"Calle tries to explain DNS","body":"# What is DNS?\r\n\r\nDNS is a distributed read-mostly fault-tolerant hierarchical database,\r\nwhere different partitions are controlled by different people.\r\n\r\nThe most common _use_ of DNS, by far, is to look up IP addresses from\r\nhuman-readable names. It was originally created in order to do exactly\r\nthat. Still, if we want to understand DNS we must not confuse the tool\r\nwith what the tool is used for. DNS is a database. A very specialized\r\none, and a fairly odd one, but still a database. It has keys, which\r\nare used to look up (or store!) pieces of data.\r\n\r\n# How is data in DNS organized?\r\n\r\n## Part 1: the Tree\r\n\r\nThe first and most obvious structure of DNS is the tree of names. The\r\nsort of name we usually see on the Internet, like `www.google.com` is an\r\naddress to a specific node in this tree. Since this is a computer\r\nscience tree and not a real-world tree, the root of it is at the\r\nright-hand edge of the name. It's also invisible, so the name in the\r\nexample above is actually `www.google.com.<invisible root>`.\r\nSometimes, when we need to be really specific, we type the dot before\r\nthe invisible root, like so: `www.google.com.`.\r\n\r\nThe names in the DNS tree are addresses of _nodes_ in the tree.\r\n`www.google.com` is the address of a node. `google.com` is the address\r\nof a different node, and `com` is another one. The root node is\r\nusually written as a single dot (`.`) when we need to refer to it.\r\n\r\nWe'll get to what is _in_ the nodes in the next section.\r\n\r\nSo, if all nodes are independent and have their own addresses, what's\r\nthe point of the tree thing? Why have I bothered to mention this root\r\nthing several times already? Well, it's pretty simple. It's how we let\r\ndifferent people control different parts. In DNS, we can say \"You\r\npeople control everything from this node down\". So, for example, ICANN\r\n(the non-profit organization who controls the root node) has given\r\ncontrol of `com` to a company called Verisign, of `se` to the nation\r\nof Sweden and of `ninja` to a company called United TLD Holdco Ltd. At\r\nthe time I write this, there are a bit over nine hundred names at the\r\nroot level. We call this process of handing over control _delegation_.\r\nSo we say that ICANN has _delegated_ `mil` to the United States\r\nmilitary, and `nz` to the nation of New Zealand. Verisign, who as you\r\nremember controls `com`, has delegated `google.com` to Google.\r\n\r\nDelegation can only happen in between names (at the dots, so to\r\nspeak). It's not possible to give control of part of a name to\r\nsomeone, and another part to someone else. That's part of why when\r\nCzechoslovakia split into the Czech Republic and Slovakia back in\r\n1993, the name `cs` was retired and the newly formed nations got `cz`\r\nand `sk` instead (the other reason is that national domains are named\r\nafter their ISO 3166-1 country codes).\r\n\r\nAlso note that delegation does not _have_ to happen. It's perfectly\r\npossible to keep control of lots of levels of names below one you\r\nhave. As an example, the vast majority of people who control a domain\r\nhave a name `www` below that domain, and they keep control of it\r\nthemselves.\r\n\r\nA name and all the names below it that are not delegated to someone\r\nelse is collectively called a _zone_.\r\n\r\nWe'll get back to how delegation happens technically later, after\r\nwe've talked about a couple of other things we need to know first,\r\nsince it's one of the areas in DNS that causes the most confusion.\r\n\r\n## Part 2: the Nodes\r\n\r\nNodes in the DNS tree contain zero or more _resource records_ (nearly\r\nalways abbreviated to RR in technical texts). Each resource record\r\nhas a _class_ and a _type_, as well as some content. Let's talk about\r\nthe classes first, so we can get them out of the way and forget them.\r\n\r\nThere are three possible classes: `HS` for Hesiod, `CH` for ChaosNet\r\nand `IN` for Internet. Guess which one of those you will use very,\r\nvery nearly 100% of the time? So if you look at a zone file and wonder\r\nwhy it says `IN` everywhere, the answer is that back when all this was\r\ndesigned nobody knew that the Internet was going to wipe out all\r\ncompetition.\r\n\r\nAnyway.\r\n\r\nThe _type_ of a record is much more interesting. It specifies what\r\nkind of data the record holds. It's the equivalent of the type of a\r\ncolumn in an SQL database table, except that the actual types are\r\npretty different. There are about 75 different kinds of resource\r\nrecord types defined, but most of them are very rarely used. Only\r\nabout a dozen or so are commonly seen. The type that someone not\r\nspecifically working with DNS is most likely to encounter is `A`,\r\nwhich holds an IPv4 address. The second most likely one is `CNAME`,\r\nwhich is unfortunate, because it is also *by far* the most\r\nmisunderstood of all RR types. We'll spend a whole section on it\r\nlater, after we've talked a bit about how delegation works.\r\n\r\nOther resource record types that may be interesting to at least have\r\nheard the names of are:\r\n\r\n* SOA\r\n    \r\n    \"Start Of Authority\". This one must exist at the top level of each\r\n    zone, and holds some information that pertains to the zone as a\r\n    whole, such as how long caches are allowed to remember data about\r\n    it without checking with a source.\r\n\r\n* MX\r\n    \r\n    \"Mail eXchange\". This one tells mail transfer agents which server\r\n    they should talk to in order to deliver mail addressed to the\r\n    domain.\r\n\r\n* TXT\r\n    \r\n    \"TeXT\". Just a bit of text. This can have something to do with DNS\r\n    itself (the `se` zone uses one to let people know the last time\r\n    the zone was updated), or be something completely different (at\r\n    least one person have used them to implement a text adventure\r\n    game).\r\n\r\n## Putting it together a little\r\n\r\nSo we have names, which point out nodes, and in the nodes there are\r\nrecords which hold data. In order to find something, for example the\r\nIPv6 addresses associated with the name `www.facebook.com`, we use\r\nthree things as a lookup key: the name, the RR class and the RR type.\r\nThe name, `www.facebook.com`, says which node to look in, while the\r\nclass and type says which records in that node we want. Since the RR\r\nclass is in practice always `IN`, we often talk about lookups as being\r\n\"an AAAA lookup for www.facebook.com\" (AAAA is the RR type for IPv6\r\naddresses, if you didn't guess that). There can be many records in a\r\nnode with the same class and type, as long as they have different data\r\nin them. It's also possible for a node to have no records at all in it.\r\n\r\n# Looking Things Up\r\n\r\n## Climbing down the tree\r\n\r\nLike all databases, DNS has servers. Unlike most databases, it has\r\n_millions_ of servers. The tricky part of looking things up in DNS is\r\nto figure out which server to ask. Fortunately, there's a procedure\r\nfor it. We start at the root, and follow a trail down. Or, I guess,\r\nfollow it left, to keep the tree directed the same way as we had it\r\nearlier in this text. Somewhat simplified, if we want to look up the\r\nIPv4 address for `www.example.org` it goes like this:\r\n\r\n1) We: \"Root servers? Give me A records for www.example.org.\"\r\n\r\n2) Root servers: \"www.example.org? Go ask the servers for org.\"\r\n\r\n3) We: \"Org servers? Give me A records for www.example.org.\"\r\n\r\n4) Org servers: \"www.example.org? Go ask the servers for example.org.\"\r\n\r\n5) We: \"Example.org servers? Give me A records for www.example.org.\"\r\n\r\n6) Example.org servers: \"Sure. Here you are.\"\r\n\r\nIt's a bit more complicated in practice, of course, since we have to\r\nfind the IP addresses for all those name servers. And we need to\r\nhandle that sometimes things don't work out as they're supposed to.\r\nMaybe the `example.org` servers give us an answer that's not so\r\nhelpful (\"Go ask the root servers\"), gives us one that's complete\r\nnonsense (\"CROCODILES!\") or don't answer at all. But roughly speaking\r\nthis is how it works.\r\n\r\nThis process of following pointers down the tree is known as doing a\r\n_recursive query_ or _recursing_.\r\n\r\n## Delegation\r\n\r\nIn the description above, we blithely skate over the phrase \"ask the\r\nservers for\". Let's get into that a bit more.\r\n\r\nEvery zone has a set of servers that have _authoritative_ information\r\nabout the zone. That is, information that has been directly input from\r\noutside the DNS system, and is treated as correct by definition. How\r\nmany such servers a zone has is up to the zone's operators, but it is\r\nvery strongly recommended that there be at least two. The list of\r\nauthoritative name servers for a zone is stored as NS records at the\r\ntopmost name of the zone. That is, the list of name servers for\r\n`example.org` is stored as `NS` resource records in the DNS tree node\r\n`example.org`.\r\n\r\nAnd therein lies a bootstrapping problem. Look at steps 2 and 4 in the\r\ndescription of the recursion process above. It's all fine and good to\r\ntell us to go ask another zone's servers, but how do we know which\r\nthose servers are? Well, the answer to that is actually really easy. A\r\nlist of them is included in the response. Except that only pushes the\r\nproblem up a step, because how do the root zone servers know about the\r\nservers for `org` or the `org` servers know about the servers for\r\n`example.org`. It gets even worse if the servers are _in_ the zone\r\nbeing looked up (`ns1.example.org` and `ns2.example.org`, say),\r\nbecause then in order to look up their IP addresses we already have\r\nknow their IP addresses.\r\n\r\nThis deadlock is broken by manual intervention. When a zone is\r\ndelegated, information about its nameservers is added to the\r\n_delegating_ zone. So externally added information about a zone's name\r\nservers exists in two places: in the zone's own authoritative name\r\nservers and in the delegating zone's name servers. To use the nodes in\r\na tree model, it is as if the node where a delegation happens has a\r\n\"shadow\" node behind it, that belongs to the zone above and only has\r\nname server information in it. The IP address information in the\r\n\"shadow\" node (if any) is usually called \"glue\", since it's used to\r\nstick the delegated zone to the delegating zone. You could see it as\r\ngluing the branch to the tree, I guess.\r\n\r\nThe problem here, and the part that causes endless confusion, is that\r\nthe information in the two nodes (the real one and the shadow one) has\r\nto be kept consistent manually. If there's a change of name server, it\r\nhas to be noted in _both_ places. Service providers often try to hide\r\nthis from end users in their various control panels and other user\r\ninterfaces, which is a nice thought but (in my opinion) only adds to\r\nthe confusion in the long run.\r\n\r\nAnd now it's time for a really scary part.\r\n\r\n## The Horror of CNAME\r\n\r\nIf you've been doing web stuff, you've heard about CNAME. Most likely,\r\nyou have no idea what it actually is, except that it is some sort of\r\nmagic that makes a URL go somewhere else. The amount of confusion\r\nabout this that can be found even on very serious question-and-answer\r\nsites (like Stack Overflow and Serverfault) is staggering. Indeed,\r\nexposure to it prompted the writing of this text, in the hope that\r\nmaybe it will stop someone somewhere at some time from having to ask a\r\nreally ignorant question.\r\n\r\nSo anyway.\r\n\r\nCNAME is a resource record type (type number 5, to be precise). The\r\ndata stored in it is a domain name. What it does is this:\r\n\r\n    If, when doing a recursive domain name lookup, the name being\r\n    looked up does not have any records of the requested type, but it\r\n    does have a record of type CNAME, the lookup is restarted with the\r\n    name from the CNAME record (unless the type queried for was CNAME,\r\n    in which case the lookup is complete and the CNAME record itself\r\n    is the response), and the result of this lookup is used as the\r\n    result of the original query.\r\n\r\nPhew! Let's pick that apart, shall we? An example is probably easiest.\r\n\r\nLet's say we want to look up the IPv6 addresses of `www.facebook.com`.\r\nWe issue a recursive query for `AAAA` records for the name\r\n`www.facebook.com` (and of class `IN`, of course). The recursion goes\r\nfrom the root to `com` to `facebook.com`. The servers for\r\n`facebook.com` tell us that there are no `AAAA` records for\r\n`www.facebook.com`, but there _is_ a `CNAME` record. The name stored\r\nin the `CNAME` is `star.c10r.facebook.com.`.\r\n\r\nSo we restart the query. Same record type, same record class,\r\ndifferent name. We go from the root, to `com`, to `facebook.com`, to\r\n`c10r.facebook.com`, which tells us that there is an `AAAA` record for\r\nthe name `star.c10r.facebook.com.`, and the IPv6 address is\r\n`2a03:2880:2110:df07:face:b00c::1`. Which then is the result of the\r\noriginal query for `www.facebook.com`'s `AAAA` records.\r\n\r\nThat's what a `CNAME` does. That's _all_ a `CNAME` does. It says to do\r\nthe query over with a different name, and pretend the result was for\r\nthe original name.\r\n\r\nOK, there is one more wrinkle. If we have a `CNAME` record in a node,\r\nwe must not have any other records in the same node (except if the\r\nzone is using DNSSEC, in which case the node may also have `RRSIG`,\r\n`NSEC` and `NSEC3`, but you can safely pretend I never even wrote\r\nthat). The reasons for this are kind of technical and esoteric, but\r\nfor the most part boil down to \"What the heck would it *mean*?\".\r\n\r\nAn immediate consequence of this rule is that we can't have a CNAME at\r\nthe top level of a zone, since it would collide at least with the `NS`\r\nand `SOA` records that must exist there (and the `MX` that usually does).\r\nThis annoys web hosting providers. Why it does is left as an exercise\r\nfor the interested reader.\r\n\r\n# DNSSEC\r\n\r\nLet's conclude by saying something about DNSSEC, the addition to the\r\nbase DNS system that makes it possible to be sure that the data we\r\nfind in DNS is not fake.\r\n\r\n## The Problem\r\n\r\nDNS was designed back when the Internet was a nice place, where\r\neveryone could be trusted to behave. \r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}